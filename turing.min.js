/**
   The core turing library. We will extend the functinality of the turing library
   through the mentioned turing.functional.js
**/
(function (global) {
    var turing = {
        version: "0.0.1",
        description: "A simple library to learn how to write a javascript framework"
    };
    if (global.turing) {
        throw new Error("Turing has already been defined");
    } else {
        global.turing = turing;
    }
    turing.types = {
        number: function (object) {
            return (object === +object) || (toString.call(object) === '[object Number]');
        },
        array: function (object) {
            return (toString.call(object) === "[object Array]");
        },
        object: function (object) {
            return Object.prototype.toString.call(object) == "[object Object]";
        }
    }
    turing.Class = function () {
        return turing.oo.create.apply(this, arguments);
    }

    turing.oo = {
        create: function () {
            var methods = null,
                parent = undefined,
                klass = function () {
                    this.$super = function (method, args) {
                        return turing.oo.$super(this.$parent, this, method, args);
                    };
                    this.initialize.apply(this, arguments);
                };

            if (typeof arguments[0] === 'function') {
                parent = arguments[0];
                methods = arguments[1];
            } else {
                methods = arguments[0];
            }

            if (typeof parent !== 'undefined') {
                turing.oo.extend(klass.prototype, parent.prototype);
                klass.prototype.$parent = parent.prototype;
            }

            turing.oo.mixin(klass, methods);
            turing.oo.extend(klass.prototype, methods);
            klass.prototype.constructor = klass;

            if (!klass.prototype.initialize)
                klass.prototype.initialize = function () {};

            return klass;
        },

        mixin: function (klass, methods) {
            if (typeof methods.include !== 'undefined') {
                if (typeof methods.include === 'function') {
                    turing.oo.extend(klass.prototype, methods.include.prototype);
                } else {
                    for (var i = 0; i < methods.include.length; i++) {
                        turing.oo.extend(klass.prototype, methods.include[i].prototype);
                    }
                }
            }
        },

        extend: function (destination, source) {
            for (var property in source)
                destination[property] = source[property];
            return destination;
        },

        $super: function (parentClass, instance, method, args) {
            return parentClass[method].apply(instance, args);
        }
    };
    turing.enumerable = {
        each: function (object, itrator, context) {
            try {
                if (Array.prototype.forEach && object.forEach == Array.prototype.forEach) {
                    return Array.prototype.forEach.call(object, iterator, context);
                } else {
                    if (turing.types.isNumber(object.length)) /*Means it is an array*/ {
                        for (var i = 0; i != object.length; i++) {
                            iterator.call(context, object[i], i, object);
                        }
                    } else {
                        for (var keys in object) {
                            if (object.hasOwnProperty(key)) {
                                iterator.call(context, object[keys], keys, object);
                            }
                        }
                    }
                }
            } catch (e) {
                if (e != turing.enumerable.Break) throw e;
                return object;
            }
        },

        map: function (object, callback, context) {
            var ret = [];
            if (Array.prototype.map && object.map == Array.prototype.map) {
                return object.map(callback, context);
            } else {
                if (turing.enumerable.isNumber(object.length)) {
                    var result = [];

                    for (var i = 0; i != object.length; i++) {
                        results.push(callback.call(context, object[i], i, object));
                    }
                    return result;
                } else {
                    var result = {};
                    for (key in object) {
                        if (object.hasOwnProperty(key)) {
                            result[key] = callback.call(context, object[key], key, object);
                        }
                    }
                    return result;
                }
            }
        },
        /*Returns the filtered values based on the callback*/
        filter: function (object, callback, context) {
            if (Array.prototype.filter && object.filter == Array.prototype.filter) {
                return object.filter(callback, context);
            }
            var results = [];
            turing.enumerable.each(object, function (val, object, context) {
                if (callback.call(context, val, object)) {
                    results.push(val);
                }
            });
            return results;
        },
        Break: {},
        /*finds the first truthy value and returns there */
        detect: function (object, callback, context) {
            turing.enumerable.each(object, function (val, index, object) {
                if (callback.call(context, val, index, object)) {
                    throw turing.enumerable.Break;
                }
            })
        },
        /*Takes the initial value. Applies a function on it. And reduces it all to 1*/
        reduce: function (object, callback, init) {
            if (arguments.length != 3) {
                throw new turing.exception.Err("Incorrect use of arguments");
            }
            var return_value = init;
            turing.enumerable.each(object, function (value, index, object) {
                return_value = callback.call(return_value, value, index, object);
            });
            return return_value;
        },
        /*Looks through each value in the list, returning the first one that passes
        a truth test (iterator), or undefined if no value passes the test.*/
        find: function (list, iterator, context) {
            if (turing.types.array(list)) {
                for (var i = 0; i != list.length; i++) {
                    if (iterator.call(context, list[i], i, list)) {
                        // first truthy value. Break and return
                        return i;
                    }
                }
            } else { // it is an array 
                for (var values in list) {
                    if (iterator.call(context, list[values], values, list)) {
                        return values;
                    }
                }
            }
        },
        /*
        Looks through each value in the list, returning an array of all the 
        values that contain all of the key-value pairs listed in properties.
        */
        where: function (list, properties) {
            if (turing.types.array(list)) {
                throw new turing.exception.Err("The passed first argument is not a list");
            } else {
                var return_set = [];
                for (var i = 0; i != list.length; i++) {
                    var element = list[i];
                    if (turing.enumerable.object(element)) {
                        var allMatched = 1;
                        for (var key in properties) {
                            if (properties[key] !== element[key]) {
                                allMatched = 0;
                            }
                        }
                        if (allMatched == 1) {
                            return_set.push(element);
                        }
                    } else {
                        throw new turing.enumerable.Err("The passed element is not an Object");
                    }
                }
                return return_set;
            }
        },
        /*Returns the values in list without the elements that the truth test 
         *(iterator) passes. The opposite of filter.
         */
        reject: function (object, callback) {
            if (turing.types.object(object)) {
                var results = {};
                for (var key in object) {
                    if (!callback.call(object[key], key, object, context)) {
                        results.key = object[key];
                    }
                }
                return results;
            } else {
                var results = [];
                for (var i = 0; i != object.length; i++) {
                    if (!callback.call(object[i], i, object, context)) {
                        results.push(object[i]);
                    }
                }
                return object[i];
            }
        },
        /* Returns true if all of the values in the list pass the iterator truth 
        test. Delegates to the native method every, if present.*/
        every: function (object, callback) {
            if (Array.prototype.every && object.every == Array.prototype.every) {
                return Array.prototype.every.call(object, callback);
            } else {
                var passedEvery = 1;
                turing.enumerable.every(object, function (value, index, object, context) {
                    if (!callback.call(value, index, object, context)) {
                        passedEvery = 1;
                        throw Break;
                    }
                });
                if (passedEvery) {
                    return true;
                } else {
                    return false;
                }
            }
        },
        /*
        A convenient version of what is perhaps the most common use-case for 
        map: extracting a list of property values.
        */
        pluck: function (object, properties) {
            var return_value = [];
            for (var i = 0; i != object.length; i++) {
                var return_element = {};
                for (var key in properties) {

                    return_element.key = object[key];
                }
                return_value.push(return_element);
            }
            return return_value;
        },
        /*
        Returns the maximum value in list. If iterator is passed, it will be 
        used on each value to generate the criterion by which the value is 
        ranked.
        */
        max: function (object, comparator) {
            var maximum_value = undefined;
            turing.enumerable.each(object, function (item, index, object) {
                if (index == 0) {
                    maximum_value = comparator.apply(item, index, object);
                } else {
                    var current_value = comparator.apply(item, index, object);
                    maximum_value = (current_value > maximum_value) ? current_value :
                        maximum_value;
                }
            });
            return maximum_value;
        },
        /*
        Computes the union of the passed-in arrays: the list of unique items, 
        in order, that are present in one or more of the arrays.
        */
        union: function () {
            var union_result = [];
            for (var i = 0; i != arguments.length; i++) {
                union_result = turing.utility.union(union_result, arguments[i]);
            }
            return union_result;
        },
        chain: function (values) {
            return new Chainer(values);
        }
    };

    var Chainer = turing.Class() {
        initialize(values) {
            this.values = values;
        }
        values: function () {
            return this.values;
        }
    };
    // Map selected methods by wrapping them in a closure that returns this each time
    turing.enumerable.each(['map', 'detect', 'filter'], function (methodName) {
        var method = turing.enumerable[methodName];
        turing.enumerable.Chainer.prototype[methodName] = function () {
            var args = Array.prototype.slice.call(arguments);
            args.unshift(this.results);
            this.results = method.apply(this, args);
            return this;
        }
    });
    /*Some utility methods required by the other functions in turing */
    turing.utility = {

        union: function (list1, list2) {
            var return_result = [];
            var caching_set = {};
            var len = Math.max(list1.length, list2.length);
            for (var i = 0; i != len; i++) {
                if (list1[i] != undefined && caching_set[list1[i]]) {
                    caching_set[list1[i]] = true;
                    return_result.push(list1[i]);
                }
                if (list2[i] != undefined && caching_set[list2[i]]) {
                    caching_set[list1[i]] = true;
                    return_result.push(list2[i]);
                }
            }
            return return_result;
        }
    };
    turing.dom = {
      find: function(){
          
      }  ,  
      findMap: {
          'name': function(root , selector){
              
          },
          'id': function(root , selector){
              
          },
          'class': function(root , selector){
              
          },
          'name and id': function(root , selector){
              
          },
          'name and class': function(root , selector){
              
          }
      } , 
      Token : function(identity , finder){
          this.identity = identity ;
          this.finder   = finder ;
          toString = function(){
              return 'identity: ' + this.identity + ', finder: ' + this.finder;
          }
        /*Macors will help drive our tokenizer with very much ease*/
          macros = {
              'nl':        '\n|\r\n|\r|\f',
              'nonascii':  '[^\0-\177]',
              'unicode':   '\\[0-9A-Fa-f]{1,6}(\r\n|[\s\n\r\t\f])?',
              'escape':    '#{unicode}|\\[^\n\r\f0-9A-Fa-f]',
              'nmchar':    '[_A-Za-z0-9-]|#{nonascii}|#{escape}',
              'nmstart':   '[_A-Za-z]|#{nonascii}|#{escape}',
              'ident':     '[-@]?(#{nmstart})(#{nmchar})*',
              'name':      '(#{nmchar})+'
            };

            rules = {
              'id and name':    '(#{ident}##{ident})',
              'id':             '(##{ident})',
              'class':          '(\\.#{ident})',
              'name and class': '(#{ident}\\.#{ident})',
              'element':        '(#{ident})',
              'pseudo class':   '(:#{ident})'
            };
      },
    };
    // Some defined prototypes 
    turing.enumerable.select = turing.enumerable.filter;
    // Turing's exception handling class
    turing.exception.Err = function (message) {
        toString: function () {
            return "Error occured " + mesage;
        }
    };

})(typeof window == "undefined" ? this : window);